{"ast":null,"code":"/**\r\n * 地理计算工具类\r\n * 提供坐标转换、距离计算、几何操作等地理空间算法\r\n */\nclass GeoUtils {\n  /**\r\n   * 地球半径（千米）\r\n   */\n  static EARTH_RADIUS = 6371.0088;\n\n  /**\r\n   * 将角度转换为弧度\r\n   * @param {number} degrees - 角度值\r\n   * @returns {number} 弧度值\r\n   */\n  static toRadians(degrees) {\n    return degrees * Math.PI / 180;\n  }\n\n  /**\r\n   * 将弧度转换为角度\r\n   * @param {number} radians - 弧度值\r\n   * @returns {number} 角度值\r\n   */\n  static toDegrees(radians) {\n    return radians * 180 / Math.PI;\n  }\n\n  /**\r\n   * 计算两点之间的地理距离（Haversine公式）\r\n   * @param {Object} point1 - 第一个点 {lng, lat}\r\n   * @param {Object} point2 - 第二个点 {lng, lat}\r\n   * @param {string} unit - 单位 ('km' 或 'm')\r\n   * @returns {number} 两点之间的距离\r\n   */\n  static calculateDistance(point1, point2, unit = 'km') {\n    const lat1 = this.toRadians(point1.lat);\n    const lon1 = this.toRadians(point1.lng);\n    const lat2 = this.toRadians(point2.lat);\n    const lon2 = this.toRadians(point2.lng);\n    const dLat = lat2 - lat1;\n    const dLon = lon2 - lon1;\n    const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(lat1) * Math.cos(lat2) * Math.sin(dLon / 2) * Math.sin(dLon / 2);\n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n    let distance = this.EARTH_RADIUS * c;\n    if (unit === 'm') {\n      distance *= 1000;\n    }\n    return distance;\n  }\n\n  /**\r\n   * 计算多边形面积\r\n   * @param {Array<Object>} polygon - 多边形顶点数组 [{lng, lat}, ...]\r\n   * @returns {number} 面积（平方千米）\r\n   */\n  static calculatePolygonArea(polygon) {\n    if (polygon.length < 3) return 0;\n    let area = 0;\n    const n = polygon.length;\n    for (let i = 0; i < n; i++) {\n      const j = (i + 1) % n;\n      const xi = this.toRadians(polygon[i].lng);\n      const yi = this.toRadians(polygon[i].lat);\n      const xj = this.toRadians(polygon[j].lng);\n      const yj = this.toRadians(polygon[j].lat);\n      area += (xj - xi) * Math.cos((yi + yj) / 2);\n    }\n    area = Math.abs(area) * this.EARTH_RADIUS * this.EARTH_RADIUS / 2;\n    return area;\n  }\n\n  /**\r\n   * 检查点是否在多边形内部\r\n   * @param {Object} point - 点 {lng, lat}\r\n   * @param {Array<Object>} polygon - 多边形顶点数组 [{lng, lat}, ...]\r\n   * @returns {boolean} 是否在内部\r\n   */\n  static isPointInPolygon(point, polygon) {\n    const x = point.lng;\n    const y = point.lat;\n    let inside = false;\n    for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {\n      const xi = polygon[i].lng;\n      const yi = polygon[i].lat;\n      const xj = polygon[j].lng;\n      const yj = polygon[j].lat;\n      const intersect = yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi;\n      if (intersect) inside = !inside;\n    }\n    return inside;\n  }\n\n  /**\r\n   * 生成缓冲区\r\n   * @param {Object} point - 中心点 {lng, lat}\r\n   * @param {number} radius - 半径（米）\r\n   * @param {number} segments - 分段数\r\n   * @returns {Array<Object>} 缓冲区多边形顶点\r\n   */\n  static createBuffer(point, radius, segments = 32) {\n    const {\n      lng,\n      lat\n    } = point;\n    const radiusInDegrees = radius / 111319.9; // 近似 1 米对应的经度度数\n    const points = [];\n    for (let i = 0; i < segments; i++) {\n      const angle = i / segments * 2 * Math.PI;\n      const dx = radiusInDegrees * Math.cos(angle);\n      const dy = radiusInDegrees * Math.sin(angle) / Math.cos(this.toRadians(lat));\n      points.push({\n        lng: lng + dx,\n        lat: lat + dy\n      });\n    }\n\n    // 闭合多边形\n    points.push(points[0]);\n    return points;\n  }\n\n  /**\r\n   * WGS84 转 GCJ02 (火星坐标系)\r\n   * @param {Object} point - WGS84 坐标 {lng, lat}\r\n   * @returns {Object} GCJ02 坐标 {lng, lat}\r\n   */\n  static wgs84ToGcj02(point) {\n    const {\n      lng,\n      lat\n    } = point;\n    // 实现 WGS84 到 GCJ02 的转换算法\n    // 这里省略具体实现，可以使用第三方库如 proj4js\n    return {\n      lng,\n      lat\n    }; // 占位返回\n  }\n\n  /**\r\n   * GCJ02 转 WGS84\r\n   * @param {Object} point - GCJ02 坐标 {lng, lat}\r\n   * @returns {Object} WGS84 坐标 {lng, lat}\r\n   */\n  static gcj02ToWgs84(point) {\n    const {\n      lng,\n      lat\n    } = point;\n    // 实现 GCJ02 到 WGS84 的转换算法\n    // 这里省略具体实现，可以使用第三方库如 proj4js\n    return {\n      lng,\n      lat\n    }; // 占位返回\n  }\n\n  /**\r\n   * 点聚类算法\r\n   * @param {Array<Object>} points - 点数组 [{lng, lat}, ...]\r\n   * @param {number} radius - 聚类半径（米）\r\n   * @returns {Array<Object>} 聚类结果 [{center: {lng, lat}, points: [...]}, ...]\r\n   */\n  static clusterPoints(points, radius) {\n    const clusters = [];\n    const processed = new Set();\n    for (let i = 0; i < points.length; i++) {\n      if (processed.has(i)) continue;\n      const cluster = {\n        center: points[i],\n        points: [points[i]]\n      };\n      processed.add(i);\n      for (let j = i + 1; j < points.length; j++) {\n        if (processed.has(j)) continue;\n        const distance = this.calculateDistance(points[i], points[j], 'm');\n        if (distance <= radius) {\n          cluster.points.push(points[j]);\n          processed.add(j);\n        }\n      }\n\n      // 重新计算聚类中心\n      cluster.center = this.calculateCentroid(cluster.points);\n      clusters.push(cluster);\n    }\n    return clusters;\n  }\n\n  /**\r\n   * 计算点集的质心\r\n   * @param {Array<Object>} points - 点数组 [{lng, lat}, ...]\r\n   * @returns {Object} 质心坐标 {lng, lat}\r\n   */\n  static calculateCentroid(points) {\n    if (points.length === 0) return {\n      lng: 0,\n      lat: 0\n    };\n    let sumLng = 0;\n    let sumLat = 0;\n    for (const point of points) {\n      sumLng += point.lng;\n      sumLat += point.lat;\n    }\n    return {\n      lng: sumLng / points.length,\n      lat: sumLat / points.length\n    };\n  }\n}\nexport default GeoUtils;","map":{"version":3,"names":["GeoUtils","EARTH_RADIUS","toRadians","degrees","Math","PI","toDegrees","radians","calculateDistance","point1","point2","unit","lat1","lat","lon1","lng","lat2","lon2","dLat","dLon","a","sin","cos","c","atan2","sqrt","distance","calculatePolygonArea","polygon","length","area","n","i","j","xi","yi","xj","yj","abs","isPointInPolygon","point","x","y","inside","intersect","createBuffer","radius","segments","radiusInDegrees","points","angle","dx","dy","push","wgs84ToGcj02","gcj02ToWgs84","clusterPoints","clusters","processed","Set","has","cluster","center","add","calculateCentroid","sumLng","sumLat"],"sources":["d:/Graduate/graduate-1/SicnuGisProject/SicnuGeo/shared-city-version/src/utils/geo.utils.js"],"sourcesContent":["/**\r\n * 地理计算工具类\r\n * 提供坐标转换、距离计算、几何操作等地理空间算法\r\n */\r\nclass GeoUtils {\r\n  /**\r\n   * 地球半径（千米）\r\n   */\r\n  static EARTH_RADIUS = 6371.0088\r\n\r\n  /**\r\n   * 将角度转换为弧度\r\n   * @param {number} degrees - 角度值\r\n   * @returns {number} 弧度值\r\n   */\r\n  static toRadians(degrees) {\r\n    return degrees * Math.PI / 180\r\n  }\r\n\r\n  /**\r\n   * 将弧度转换为角度\r\n   * @param {number} radians - 弧度值\r\n   * @returns {number} 角度值\r\n   */\r\n  static toDegrees(radians) {\r\n    return radians * 180 / Math.PI\r\n  }\r\n\r\n  /**\r\n   * 计算两点之间的地理距离（Haversine公式）\r\n   * @param {Object} point1 - 第一个点 {lng, lat}\r\n   * @param {Object} point2 - 第二个点 {lng, lat}\r\n   * @param {string} unit - 单位 ('km' 或 'm')\r\n   * @returns {number} 两点之间的距离\r\n   */\r\n  static calculateDistance(point1, point2, unit = 'km') {\r\n    const lat1 = this.toRadians(point1.lat)\r\n    const lon1 = this.toRadians(point1.lng)\r\n    const lat2 = this.toRadians(point2.lat)\r\n    const lon2 = this.toRadians(point2.lng)\r\n\r\n    const dLat = lat2 - lat1\r\n    const dLon = lon2 - lon1\r\n\r\n    const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +\r\n              Math.cos(lat1) * Math.cos(lat2) *\r\n              Math.sin(dLon / 2) * Math.sin(dLon / 2)\r\n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a))\r\n\r\n    let distance = this.EARTH_RADIUS * c\r\n\r\n    if (unit === 'm') {\r\n      distance *= 1000\r\n    }\r\n\r\n    return distance\r\n  }\r\n\r\n  /**\r\n   * 计算多边形面积\r\n   * @param {Array<Object>} polygon - 多边形顶点数组 [{lng, lat}, ...]\r\n   * @returns {number} 面积（平方千米）\r\n   */\r\n  static calculatePolygonArea(polygon) {\r\n    if (polygon.length < 3) return 0\r\n\r\n    let area = 0\r\n    const n = polygon.length\r\n\r\n    for (let i = 0; i < n; i++) {\r\n      const j = (i + 1) % n\r\n      const xi = this.toRadians(polygon[i].lng)\r\n      const yi = this.toRadians(polygon[i].lat)\r\n      const xj = this.toRadians(polygon[j].lng)\r\n      const yj = this.toRadians(polygon[j].lat)\r\n\r\n      area += (xj - xi) * Math.cos((yi + yj) / 2)\r\n    }\r\n\r\n    area = Math.abs(area) * this.EARTH_RADIUS * this.EARTH_RADIUS / 2\r\n    return area\r\n  }\r\n\r\n  /**\r\n   * 检查点是否在多边形内部\r\n   * @param {Object} point - 点 {lng, lat}\r\n   * @param {Array<Object>} polygon - 多边形顶点数组 [{lng, lat}, ...]\r\n   * @returns {boolean} 是否在内部\r\n   */\r\n  static isPointInPolygon(point, polygon) {\r\n    const x = point.lng\r\n    const y = point.lat\r\n    let inside = false\r\n\r\n    for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {\r\n      const xi = polygon[i].lng\r\n      const yi = polygon[i].lat\r\n      const xj = polygon[j].lng\r\n      const yj = polygon[j].lat\r\n\r\n      const intersect = ((yi > y) !== (yj > y)) &&\r\n                       (x < (xj - xi) * (y - yi) / (yj - yi) + xi)\r\n      if (intersect) inside = !inside\r\n    }\r\n\r\n    return inside\r\n  }\r\n\r\n  /**\r\n   * 生成缓冲区\r\n   * @param {Object} point - 中心点 {lng, lat}\r\n   * @param {number} radius - 半径（米）\r\n   * @param {number} segments - 分段数\r\n   * @returns {Array<Object>} 缓冲区多边形顶点\r\n   */\r\n  static createBuffer(point, radius, segments = 32) {\r\n    const { lng, lat } = point\r\n    const radiusInDegrees = radius / 111319.9 // 近似 1 米对应的经度度数\r\n    const points = []\r\n\r\n    for (let i = 0; i < segments; i++) {\r\n      const angle = (i / segments) * 2 * Math.PI\r\n      const dx = radiusInDegrees * Math.cos(angle)\r\n      const dy = radiusInDegrees * Math.sin(angle) / Math.cos(this.toRadians(lat))\r\n\r\n      points.push({\r\n        lng: lng + dx,\r\n        lat: lat + dy\r\n      })\r\n    }\r\n\r\n    // 闭合多边形\r\n    points.push(points[0])\r\n\r\n    return points\r\n  }\r\n\r\n  /**\r\n   * WGS84 转 GCJ02 (火星坐标系)\r\n   * @param {Object} point - WGS84 坐标 {lng, lat}\r\n   * @returns {Object} GCJ02 坐标 {lng, lat}\r\n   */\r\n  static wgs84ToGcj02(point) {\r\n    const { lng, lat } = point\r\n    // 实现 WGS84 到 GCJ02 的转换算法\r\n    // 这里省略具体实现，可以使用第三方库如 proj4js\r\n    return { lng, lat } // 占位返回\r\n  }\r\n\r\n  /**\r\n   * GCJ02 转 WGS84\r\n   * @param {Object} point - GCJ02 坐标 {lng, lat}\r\n   * @returns {Object} WGS84 坐标 {lng, lat}\r\n   */\r\n  static gcj02ToWgs84(point) {\r\n    const { lng, lat } = point\r\n    // 实现 GCJ02 到 WGS84 的转换算法\r\n    // 这里省略具体实现，可以使用第三方库如 proj4js\r\n    return { lng, lat } // 占位返回\r\n  }\r\n\r\n  /**\r\n   * 点聚类算法\r\n   * @param {Array<Object>} points - 点数组 [{lng, lat}, ...]\r\n   * @param {number} radius - 聚类半径（米）\r\n   * @returns {Array<Object>} 聚类结果 [{center: {lng, lat}, points: [...]}, ...]\r\n   */\r\n  static clusterPoints(points, radius) {\r\n    const clusters = []\r\n    const processed = new Set()\r\n\r\n    for (let i = 0; i < points.length; i++) {\r\n      if (processed.has(i)) continue\r\n\r\n      const cluster = {\r\n        center: points[i],\r\n        points: [points[i]]\r\n      }\r\n\r\n      processed.add(i)\r\n\r\n      for (let j = i + 1; j < points.length; j++) {\r\n        if (processed.has(j)) continue\r\n\r\n        const distance = this.calculateDistance(points[i], points[j], 'm')\r\n        if (distance <= radius) {\r\n          cluster.points.push(points[j])\r\n          processed.add(j)\r\n        }\r\n      }\r\n\r\n      // 重新计算聚类中心\r\n      cluster.center = this.calculateCentroid(cluster.points)\r\n      clusters.push(cluster)\r\n    }\r\n\r\n    return clusters\r\n  }\r\n\r\n  /**\r\n   * 计算点集的质心\r\n   * @param {Array<Object>} points - 点数组 [{lng, lat}, ...]\r\n   * @returns {Object} 质心坐标 {lng, lat}\r\n   */\r\n  static calculateCentroid(points) {\r\n    if (points.length === 0) return { lng: 0, lat: 0 }\r\n\r\n    let sumLng = 0\r\n    let sumLat = 0\r\n\r\n    for (const point of points) {\r\n      sumLng += point.lng\r\n      sumLat += point.lat\r\n    }\r\n\r\n    return {\r\n      lng: sumLng / points.length,\r\n      lat: sumLat / points.length\r\n    }\r\n  }\r\n}\r\n\r\nexport default GeoUtils"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}